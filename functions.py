from abc import ABC, abstractmethod

from math import sin, cos, e, atan2, atan, sqrt, pi, exp
import operator
import numpy as np


class ConstrainedFunction(ABC):

    def __init__(self, dimensions):
        self.D = dimensions

    @abstractmethod
    def evaluate(self, X):
        pass

    @abstractmethod
    def constraints(self):
        pass

    @abstractmethod
    def get_domain(self):
        """
        Return a list of tuple representing a domain
        of admissible individuals for each dimension
        """
        pass


class Rosenbrok(ConstrainedFunction):

    def __init__(self, dimensions):
        if dimensions != 2:
            raise ValueError(f"Dimensions must be equal to 2 for function {self.__class__.__name__}")

        super().__init__(dimensions)

    def evaluate(self, X):
        """
        http://en.wikipedia.org/wiki/Rosenbrock_function
        """
        x = X[0]
        y = X[1]
        a = 1. - x
        b = y - x * x
        return a * a + b * b * 100.

    def constraints(self):
        """
        http://en.wikipedia.org/wiki/Test_functions_for_optimization
        """
        return {
            "g1":
                {
                    "name": "g1",
                    "func": lambda x: (x[0] - 1.) ** 3. - x[1] + 1.,
                    "op": operator.le,
                    "target": lambda x: 0
                },
            "g2":
                {
                    "name": "g2",
                    "func": lambda x: x[0] + x[1] - 2.,
                    "op": operator.le,
                    "target": lambda x: 0
                }
        }

    def get_domain(self):
        return [
            (-1.5, 1.5),
            (-0.5, 2.5)
        ]


class MishraBird(ConstrainedFunction):

    def __init__(self, dimensions):
        if dimensions != 2:
            raise ValueError(f"Dimensions must be equal to 2 for function {self.__class__.__name__}")

        super().__init__(dimensions)

    def evaluate(self, X):
        x = X[0]
        y = X[1]
        a = 1. - cos(x)
        b = 1. - sin(y)
        c = x - y
        return sin(y) * e ** (a * a) + cos(x) * e ** (b * b) + c * c

    def constraints(self):
        """
        http://en.wikipedia.org/wiki/Test_functions_for_optimization
        """
        return {
            "g1":
                {
                    "name": "g1",
                    "func": lambda x: (x[0] + 5) ** 2 + (x[1] + 5) ** 2,
                    "op": operator.lt,
                    "target": lambda x: 0
                }
        }

    def get_domain(self):
        return [
            (-10, 0),
            (-6.5, 0)
        ]


class Townsend(ConstrainedFunction):

    def __init__(self, dimensions):
        if dimensions != 2:
            raise ValueError(f"Dimensions must be equal to 2 for function {self.__class__.__name__}")

        super().__init__(dimensions)

    def evaluate(self, X):
        x = X[0]
        y = X[1]
        a = (x - 0.1) * y
        b = cos(a) ** 2
        c = 3 * x + y
        d = x * sin(c)
        return (b * (-1.)) - d

    def constraints(self):
        def const1(X):
            x = X[0]
            y = X[1]
            t = atan2(x, y)
            a = (2 * cos(t)) - (0.5 * cos(2 * t)) - (0.25 * cos(3 * t)) - (0.125 * cos(4 * t))
            return a ** 2 + (2 * sin(t)) ** 2

        return {
            "g1":
                {
                    "name": "g1",
                    "func": const1,
                    "op": operator.gt,
                    "target": lambda x: x[0] ** 2 + x[1] ** 2
                }
        }

    def get_domain(self):
        return [
            (-2.25, 2.5),
            (-2.5, 1.75)
        ]


# TODO: Crea numeri complessi?
class Simionescu(ConstrainedFunction):

    def __init__(self, dimensions):
        if dimensions != 2:
            raise ValueError(f"Dimensions must be equal to 2 for function {self.__class__.__name__}")

        super().__init__(dimensions)

    def evaluate(self, X):
        x = X[0]
        y = X[1]
        return 0.1 * x * y

    def constraints(self):
        def const1(X):
            x = X[0]
            y = X[1]
            rt = 1.
            rs = 0.2
            n = 8
            a = n * atan(x / y)
            b = rt + rs * a
            return b ** b

        return {
            "g1":
                {
                    "name": "g1",
                    "func": const1,
                    "op": operator.ge,
                    "target": lambda x: x[0] ** 2 + x[1] ** 2
                }
        }

    def get_domain(self):
        return [
            (-1.25, 1.25),
            (-1.25, 1.25)
        ]


# ====================================================================================================
# Some functions implemented from CEC 2010 Competition on Constrained Real- Parameter Optimization
# Reference: http://www3.ntu.edu.sg/home/epnsugan/index_files/CEC10-Const/TR-April-2010.pdf
# ====================================================================================================


class C01(ConstrainedFunction):

    def __init__(self, dimensions):
        self.o = np.array(
            [0.030858718087483, -0.078632292353156, 0.048651146638038, -0.069089831066354, -0.087918542941928,
             0.088982639811141, 0.074143235639847, -0.086527593580149, -0.020616531903907, 0.055586106499231,
             0.059285954883598, -0.040671485554685, -0.087399911887693, -0.01842585125741, -0.005184912793062,
             -0.039892037937026, 0.036509229387458, 0.026046414854433, -0.067133862936029, 0.082780189144943,
             -0.049336722577062, 0.018503188080959, 0.051610619131255, 0.018613117768432, 0.093448598181657,
             -0.071208840780873, -0.036535677894572, -0.03126128526933, 0.099243805247963, 0.053872445945574])

        if dimensions > len(self.o):
            raise ValueError("Dimensions cannot be higher than o vector")

        super().__init__(dimensions)

    def evaluate(self, X):
        x = np.array(X)
        z = x - self.o[:self.D]
        a = np.sum([cos(_z) ** 4 for _z in z])
        b = 2 * np.prod([cos(_z) ** 2 for _z in z])
        c = sqrt(np.sum([i * _z ** 2 for i, _z in enumerate(z)]))
        return -1. * abs((a - b) / c)

    def constraints(self):
        def g1(X):
            x = np.array(X)
            z = x - self.o[:self.D]
            return 0.75 - np.prod(z)

        def g2(X):
            x = np.array(X)
            z = x - self.o[:self.D]
            return np.sum(z) - 7.5 * self.D

        return {
            "g1":
                {
                    "name": "g1",
                    "func": g1,
                    "op": operator.le,
                    "target": lambda x: 0
                },
            "g2":
                {
                    "name": "g2",
                    "func": g2,
                    "op": operator.le,
                    "target": lambda x: 0
                }
        }

    def get_domain(self):
        return [
            (0, 10) for _ in range(0, self.D)
        ]


class C02(ConstrainedFunction):

    def __init__(self, dimensions):
        self.o = np.array(
            [-0.066939099286697, 0.470966419894494, -0.490528349401176, -0.312203454689423, -0.124759576300523,
             -0.247823908806285, -0.448077079941866, 0.326494954650117, 0.493435908752668, 0.061699778818925,
             -0.30251101183711, -0.274045146932175, -0.432969960330318, 0.062239193145781, -0.188163731545079,
             -0.100709842052095, -0.333528971180922, -0.496627672944882, -0.288650116941944, 0.435648113198148,
             -0.348261107144255, 0.456550427329479, -0.286843419772511, 0.145639015401174, -0.038656025783381,
             0.333291935226012, -0.293687524888766, -0.347859473554797, -0.089300971656411, 0.142027393193559])

        if dimensions > len(self.o):
            raise ValueError("Dimensions cannot be higher than o vector")

        super().__init__(dimensions)

    def evaluate(self, X):
        x = np.array(X)
        z = x - self.o[:self.D]
        return np.max(z)

    def constraints(self):
        def g1(X):
            x = np.array(X)
            z = x - self.o[:self.D]
            a = np.sum([_z ** 2 - 10 * cos(2 * pi * _z) + 10 for _z in z])
            return 10 - (1 / self.D) * a

        def g2(X):
            x = np.array(X)
            z = x - self.o[:self.D]
            a = np.sum([_z ** 2 - 10 * cos(2 * pi * _z) + 10 for _z in z])
            return (1 / self.D) * a - 15

        def h1(X):
            x = np.array(X)
            z = x - self.o[:self.D]
            # element-wise operation
            y = z - 0.5
            a = np.sum([_y ** 2 - 10 * cos(2 * pi * _y) + 10 for _y in y])
            return (1 / self.D) * a - 20

        return {
            "g1":
                {
                    "name": "g1",
                    "func": g1,
                    "op": operator.le,
                    "target": lambda x: 0
                },
            "g2":
                {
                    "name": "g2",
                    "func": g2,
                    "op": operator.le,
                    "target": lambda x: 0
                },
            "h1":
                {
                    "name": "h1",
                    "func": h1,
                    "op": operator.eq,
                    "target": lambda x: 0
                }
        }

    def get_domain(self):
        return [
            (-5.12, 5.12) for _ in range(0, self.D)
        ]


class C03(ConstrainedFunction):

    def __init__(self, dimensions):
        self.o = np.array(
            [111.17633500088529, 92.07880492633424, 417.9818592609036, 253.16188128024302, 363.5279986597767,
             314.334093889305, 187.32739056163342, 240.4363027535162, 422.60090880560665, 327.63042902581515,
             62.04762897064405, 25.435663968682125, 360.56773191905114, 154.9226721156832, 33.161292034425806,
             177.8091733067186, 262.58198940407755, 436.9800562237075, 476.6400624069227, 331.2167787340325,
             75.205948242522, 484.33624811710115, 258.4696246506982, 419.8919566566751, 357.51468895930395,
             166.3771729386268, 47.59455935830133, 188.20606700809785, 184.7964918401363, 267.9201349178807])

        if dimensions > len(self.o):
            raise ValueError("Dimensions cannot be higher than o vector")

        super().__init__(dimensions)

    def evaluate(self, X):
        x = np.array(X)
        z = x - self.o[:self.D]
        return np.sum([(100 * (z[i] ** 2 - z[i + 1])) ** 2 + (z[i] - 1) ** 2 for i in range(0, len(z) - 1)])

    def constraints(self):
        def h1(X):
            x = np.array(X)
            z = x - self.o[:self.D]
            return np.sum([(z[i] - z[i + 1]) ** 2 for i in range(0, len(z) - 1)])

        return {
            "h1":
                {
                    "name": "h1",
                    "func": h1,
                    "op": operator.eq,
                    "target": lambda x: 0
                }
        }

    def get_domain(self):
        return [
            (-1000, 1000) for _ in range(0, self.D)
        ]


class C04(ConstrainedFunction):

    def __init__(self, dimensions):
        self.o = np.array(
            [0.820202353727904, 5.260154140335203, -1.694610371739177, -5.589298730330406, -0.141736605495543,
             9.454675508078164, 8.795744608532939, 9.687346331423548, -3.246522827444976, 6.647399971577617,
             1.434490229836026, -0.506531215086801, 0.558594225280784, 7.919942423520642, 1.383716002673571,
             -1.520153615528276, -2.266737465474915, 6.48052999726508, -8.893207968949003, -3.528743044935322,
             6.063486037065154, -4.51585211274229, 7.320477892009357, -8.990263774675665, 9.446412007392851,
             -6.41068985463494, -9.135251626491991, 2.07763837492787, 8.051026378030816, -1.002691032064544])

        if dimensions > len(self.o):
            raise ValueError("Dimensions cannot be higher than o vector")

        super().__init__(dimensions)

    def evaluate(self, X):
        x = np.array(X)
        z = x - self.o[:self.D]
        return np.max(z)

    def constraints(self):
        def h1(X):
            x = np.array(X)
            z = x - self.o[:self.D]
            return (1 / self.D) * np.sum([_z * cos(sqrt(abs(_z))) for _z in z])

        def h2(X):
            x = np.array(X)
            z = x - self.o[:self.D]
            return np.sum([(z[i] - z[i + 1]) ** 2 for i in range(0, int(self.D / 2 + 1))])

        def h3(X):
            x = np.array(X)
            z = x - self.o[:self.D]
            return np.sum([(z[i] ** 2 - z[i + 1]) ** 2 for i in range(int(self.D / 2 + 1), self.D - 1)])

        def h4(X):
            x = np.array(X)
            z = x - self.o[:self.D]
            return np.sum(z)

        return {
            "h1":
                {
                    "name": "h1",
                    "func": h1,
                    "op": operator.eq,
                    "target": lambda x: 0
                },
            "h2":
                {
                    "name": "h2",
                    "func": h2,
                    "op": operator.eq,
                    "target": lambda x: 0
                },
            "h3":
                {
                    "name": "h3",
                    "func": h3,
                    "op": operator.eq,
                    "target": lambda x: 0
                },
            "h4":
                {
                    "name": "h4",
                    "func": h4,
                    "op": operator.eq,
                    "target": lambda x: 0
                }
        }

    def get_domain(self):
        return [
            (-50, 50) for _ in range(0, self.D)
        ]


class C05(ConstrainedFunction):

    def __init__(self, dimensions):
        self.o = np.array([72.10900225247575, 9.007673762322495, 51.86632637302316, 41.365704820161, 93.18768763916974,
                           74.53341902482204, 63.745479932407655, 7.496986033468282, 56.16729598807964,
                           17.71630810614085,
                           28.009655663065143, 29.36357615570272, 26.966653374740996, 6.892189514516317,
                           44.29071160734624,
                           84.35803966449319, 81.16906730972529, 92.76919270133271, 3.826058034047476,
                           7.231864548985054,
                           14.446069444832405, 46.49943418775763, 22.155722253817412, 69.11723738661682,
                           88.99628570349459,
                           58.74823912291344, 52.265369214509846, 47.030120955005074, 53.23321779503931,
                           5.778976086909701])

        if dimensions > len(self.o):
            raise ValueError("Dimensions cannot be higher than o vector")

        super().__init__(dimensions)

    def evaluate(self, X):
        x = np.array(X)
        z = x - self.o[:self.D]
        return np.max(z)

    def constraints(self):
        def h1(X):
            x = np.array(X)
            z = x - self.o[:self.D]
            return (1 / self.D) * np.sum([-1. * _z * sin(sqrt(abs(_z))) for _z in z])

        def h2(X):
            x = np.array(X)
            z = x - self.o[:self.D]
            return (1 / self.D) * np.sum([-1. * _z * cos(0.5 * sqrt(abs(_z))) for _z in z])

        return {
            "h1":
                {
                    "name": "h1",
                    "func": h1,
                    "op": operator.eq,
                    "target": lambda x: 0
                },
            "h2":
                {
                    "name": "h2",
                    "func": h2,
                    "op": operator.eq,
                    "target": lambda x: 0
                }
        }

    def get_domain(self):
        return [
            (-600, 600) for _ in range(0, self.D)
        ]


class C06(ConstrainedFunction):

    def __init__(self, dimensions):
        self.o = np.array(
            [-1.595515627742907, 7.633467047559741, -5.764100483472472, 8.103197246263033, -0.059515969417191,
             -0.737189363693078, -9.190862358160823, 4.22087353933443, -1.745435308213725, 9.499044614342985,
             3.82068618551277, 2.569334886907409, 9.354368119489862, -0.852114934846258, 4.714177466874696,
             6.775420647884232, -9.074204717422479, -3.760650327490145, -0.77805530989772, -7.487007842931314,
             4.435061566086135, -6.952711886757461, -8.752326993212105, -2.411334215593357, -6.149894283287328,
             1.049303005795593, -6.049093253116644, 0.950328133373404, 1.443084229017085, -0.163829799788475])

        self.M = np.array([[-0.427907650939441, 0.33300277992222, 0.158498600541243, 0.278765719516325,
                            0.222299060911893, -0.29474502069992, 0.370057970680927, -0.501453646373309,
                            -0.280145449898877, -0.000651265117346], [
                               0.224165315142979, -0.261710409707008, 0.461868247797853, 0.088426027905637,
                               0.181816871315433, 0.373896699539441, 0.129585371011854, -0.381595698048136,
                               0.299800543352535, 0.48473910987024], [
                               0.53537800271001, -0.346919032183315, -0.245187528106815, 0.616142955927466,
                               0.041841873460541, -0.159575037377286, 0.105947745849249, -0.048303985087219,
                               -0.328079281746379, -0.069709134117085], [
                               -0.416970506616096, -0.38848171660274, -0.094221759803838, -0.004397275883214,
                               -0.237544237428415, -0.087984765871128, 0.123623297192573, 0.287283813863898,
                               -0.330878858096249, 0.62837597392732], [
                               -0.173113815964007, -0.41172550558533, -0.499430088608083, -0.219823423370544,
                               -0.134153464975979, 0.107615420480369, 0.438598883104602, -0.36754189637868,
                               0.291862561306911, -0.24605477533745], [
                               -0.238828717007495, -0.377132503962298, -0.036565581442029, -0.115315158370499,
                               0.298745579814478, 0.119889740767446, -0.652016881734357, -0.358800646641909,
                               -0.326697807053803, -0.147917018157104], [
                               -0.430957521699839, -0.225924726595994, 0.119112314369716, 0.573035485004016,
                               0.085368416951095, -0.090379611695263, -0.158290455997733, 0.252439376164776,
                               0.529634351567821, -0.189541361218442], [
                               0.038944335110613, 0.082059986739041, -0.407974613233548, -0.116148517661389,
                               0.807124465614906, -0.104709855101281, 0.075051783295566, 0.217165356560047,
                               0.152079302286292, 0.271071947907043], [
                               0.158807462159919, -0.014816097582468, -0.081504338504322, -0.114995329704289,
                               -0.203139388356386, -0.726380618422525, -0.310128975831262, -0.313282470241953,
                               0.332760870420427, 0.284154344591495], [
                               -0.081746794746219, 0.423796877332073, -0.504499564436954, 0.34367868531852,
                               -0.228250720437377, 0.409151634256662, -0.27457871527628, -0.212617996823112,
                               0.090750526203861, 0.304532143452476]])

        if dimensions > len(self.o):
            raise ValueError("Dimensions cannot be higher than o vector")

        if dimensions != 10:
            raise ValueError(f"Dimensions must be 10 for function {self.__class__.__name__}")

        super().__init__(dimensions)

    def evaluate(self, X):
        x = np.array(X)
        z = x - self.o[:self.D]
        return np.max(z)

    def constraints(self):
        def h1(X):
            x = np.array(X)
            z = x - self.o[:self.D]
            y = self.M.dot((x + 483.6106156535 - self.o[:self.D])) - 483.6106156535
            return (1 / self.D) * np.sum([-1. * _y * sin(sqrt(abs(_y))) for _y in y])

        def h2(X):
            x = np.array(X)
            z = x - self.o[:self.D]
            y = self.M.dot((x + 483.6106156535 - self.o[:self.D])) - 483.6106156535
            return (1 / self.D) * np.sum([-1. * _y * cos(0.5 * sqrt(abs(_y))) for _y in y])

        return {
            "h1":
                {
                    "name": "h1",
                    "func": h1,
                    "op": operator.eq,
                    "target": lambda x: 0
                },
            "h2":
                {
                    "name": "h2",
                    "func": h2,
                    "op": operator.eq,
                    "target": lambda x: 0
                }
        }

    def get_domain(self):
        return [
            (-600, 600) for _ in range(0, self.D)
        ]


class C07(ConstrainedFunction):

    def __init__(self, dimensions):
        self.o = np.array(
            [-1.46823271282738, 47.51401860909492, -30.421056514069576, -7.707941671844303, -21.74698421666629,
             -17.88116387879569, 5.274442455807971, 18.71403753778708, -36.959734507345146, -20.72950462154263,
             25.4701966548936, -25.439992885801573, 1.054563129830697, -31.556579857545657, -19.320382777005047,
             17.16774285348282, 34.66536814401755, -31.803705714749462, -12.926898387712775, 25.489686517508602,
             -45.23000430753644, 36.31774710581284, -18.38690515559357, 34.86816378160691, -37.530671214167334,
             19.288852618585977, 0.684612418754519, -12.636795982748637, 15.005454148879409, -40.468678588994315])

        if dimensions > len(self.o):
            raise ValueError("Dimensions cannot be higher than o vector")

        super().__init__(dimensions)

    def evaluate(self, X):
        x = np.array(X)
        z = x + 1 - self.o[:self.D]
        return np.sum([(100 * (z[i] ** 2 - z[i + 1])) ** 2 + (z[i] - 1) ** 2 for i in range(0, len(z) - 1)])

    def constraints(self):
        def g1(X):
            x = np.array(X)
            y = x - self.o[:self.D]
            a = exp(-0.1 * sqrt(1 / self.D * np.sum(_y * _y for _y in y)))
            b = exp(1 / self.D * np.sum(cos(0.1 * _y) for _y in y))
            return 0.5 - a - 3 * b + exp(1)

        return {
            "g1":
                {
                    "name": "g1",
                    "func": g1,
                    "op": operator.le,
                    "target": lambda x: 0
                }
        }

    def get_domain(self):
        return [
            (-140, 140) for _ in range(0, self.D)
        ]


class C08(ConstrainedFunction):

    def __init__(self, dimensions):
        self.o = np.array(
            [-1.46823271282738, 47.51401860909492, -30.421056514069576, -7.707941671844303, -21.74698421666629,
             -17.88116387879569, 5.274442455807971, 18.71403753778708, -36.959734507345146, -20.72950462154263,
             25.4701966548936, -25.439992885801573, 1.054563129830697, -31.556579857545657, -19.320382777005047,
             17.16774285348282, 34.66536814401755, -31.803705714749462, -12.926898387712775, 25.489686517508602,
             -45.23000430753644, 36.31774710581284, -18.38690515559357, 34.86816378160691, -37.530671214167334,
             19.288852618585977, 0.684612418754519, -12.636795982748637, 15.005454148879409, -40.468678588994315])

        self.M = np.array([[-18.785768809450733, 33.616954860437176, 26.882113915382682, -10.43306419742936,
                            0.944892894082476, -3.353896433259691, 3.535212733907637, 7.394276941396782,
                            7.790908752641235, 2.091292109983567], [
                               -0.38080580880289, 10.420967284673154, 9.347291913115678, -20.926490513724943,
                               11.4259031588907, 1.10563725749954, 36.87928250597037, -1.910339780463472,
                               7.56116849320932, -9.743066435789972], [
                               -12.341688082549489, 6.362199355273804, 8.248429939792464, 8.089256366417835,
                               0.069234506619011, 2.578624135957486, -0.497340218618186, -2.062722095484327,
                               1.430205147745766, 15.52200376094467], [
                               -17.00654251044467, -12.679306064055677, 51.65812051951116, -3.97661207806369,
                               3.934938475013658, -30.777202564613845, 6.146597147627116, -11.404959107806402,
                               12.694206030880832, -9.395143228117439], [
                               -5.484749154282662, -13.643476981518553, -20.8125786035429, 12.48063177681885,
                               0.844978205995699, 24.830393330514045, 33.83850518570256, -17.003569707093064,
                               -5.293964367404844, 26.065703095424336], [
                               11.422878520470586, 10.221461943150496, -5.999478987400263, -8.935891602574142,
                               3.340791625151446, 3.924548854255449, -6.760571785727851, 14.016300477765046,
                               2.353396935795215, -15.957358828479556], [
                               14.1069797350053, -0.689797572922294, 25.92835826668488, -30.138271725378775,
                               12.953067028884863, -17.125782201118525, 19.122903237509483, 3.85021017121606,
                               14.44987126033593, -37.768641488073015], [
                               1.817162027385162, -4.52289774299815, 2.596064824368431, -3.077970366333548,
                               3.666238380627702, -3.142271967105208, -1.93910379576585, -1.132846020949443,
                               -1.459397119228072, -4.385065305078107], [
                               17.05963501513677, -40.88734304067851, -9.04136854737176, 9.207816613351653,
                               2.483559081696921, -3.135238286666343, -0.515970843448524, -10.448164970351954,
                               -3.97908386413912, -5.010151763870892], [
                               -2.100410473384162, 4.285743492212902, 18.13880373052391, -5.569156622351854,
                               0.020414928764168, -5.531568307180828, 1.750746232557792, 2.018382353850689,
                               8.96737078655512, -3.593654241962948]])

        if dimensions > len(self.o):
            raise ValueError("Dimensions cannot be higher than o vector")

        super().__init__(dimensions)

    def evaluate(self, X):
        x = np.array(X)
        z = x + 1 - self.o[:self.D]
        return np.sum([(100 * (z[i] ** 2 - z[i + 1])) ** 2 + (z[i] - 1) ** 2 for i in range(0, len(z) - 1)])

    def constraints(self):
        def g1(X):
            x = np.array(X)
            y = self.M.dot(x - self.o[:self.D])
            a = exp(-0.1 * sqrt(1 / self.D * np.sum(_y * _y for _y in y)))
            b = exp(1 / self.D * np.sum(cos(0.1 * _y) for _y in y))
            return 0.5 - a - 3 * b + exp(1)

        return {
            "g1":
                {
                    "name": "g1",
                    "func": g1,
                    "op": operator.le,
                    "target": lambda x: 0
                }
        }

    def get_domain(self):
        return [
            (-140, 140) for _ in range(0, self.D)
        ]


class C09(ConstrainedFunction):

    def __init__(self, dimensions):
        self.o = np.array(
            [-41.03250252873486, -35.70280591875908, -48.66938576680659, 94.51946988004894, 31.68700466174738,
             99.69508270219342, 30.778279925351967, -31.041222172110807, -46.21010370947247, 27.26190010072706,
             -2.093622677920422, 22.246274570582585, -42.887366421312436, 89.88377145577851, -6.731523713182725,
             97.86439204258224, 49.49993772881544, 23.210695390854696, -81.36716857155828, -20.15688556597543,
             36.692155371634726, 44.37408948075327, -15.984549833405907, -49.68391424581281, 98.3715576810595,
             0.127593155843627, 61.709914317965655, -84.0189999580673, -35.39565398431638, -5.143979333218638])

        if dimensions > len(self.o):
            raise ValueError("Dimensions cannot be higher than o vector")

        super().__init__(dimensions)

    def evaluate(self, X):
        x = np.array(X)
        z = x + 1 - self.o[:self.D]
        return np.sum([(100 * (z[i] ** 2 - z[i + 1])) ** 2 + (z[i] - 1) ** 2 for i in range(0, len(z) - 1)])

    def constraints(self):
        def h1(X):
            x = np.array(X)
            y = x - self.o[:self.D]
            return np.sum([_y * sin(sqrt(abs(_y))) for _y in y])

        return {
            "h1":
                {
                    "name": "h1",
                    "func": h1,
                    "op": operator.eq,
                    "target": lambda x: 0
                }
        }

    def get_domain(self):
        return [
            (-500, 500) for _ in range(0, self.D)
        ]


class C10(ConstrainedFunction):

    def __init__(self, dimensions):
        self.o = np.array(
            [-41.03250252873486, -35.70280591875908, -48.66938576680659, 94.51946988004894, 31.68700466174738,
             99.69508270219342, 30.778279925351967, -31.041222172110807, -46.21010370947247, 27.26190010072706,
             -2.093622677920422, 22.246274570582585, -42.887366421312436, 89.88377145577851, -6.731523713182725,
             97.86439204258224, 49.49993772881544, 23.210695390854696, -81.36716857155828, -20.15688556597543,
             36.692155371634726, 44.37408948075327, -15.984549833405907, -49.68391424581281, 98.3715576810595,
             0.127593155843627, 61.709914317965655, -84.0189999580673, -35.39565398431638, -5.143979333218638])

        self.M = np.array([[-0.040348736997622, -0.57547478301341, -0.389765935131311, 0.140885590781398,
                            -0.144670835908614, 0.115450535800564, -0.518304793509814, 0.149470047989466,
                            0.386138410795004, 0.145230906380518], [
                               -0.065866355431932, -0.257122057117828, 0.298076832606074, -0.339838329245853,
                               0.36335902728584, 0.69140513648482, -0.028135015592, 0.214592766458436,
                               -0.21337789362989, 0.150888625576118], [
                               -0.154282201350543, 0.233990300992969, 0.196071677766854, -0.516011967110319,
                               -0.265721705059327, -0.060905234855331, 0.017107816544837, 0.459602625258773,
                               0.548125243387881, -0.174490925899168], [
                               0.363857337521185, 0.622123871321307, 0.051207493885242, 0.281214293456459,
                               0.077610534696611, 0.38475834924149, -0.410410905293451, -0.035659107285799,
                               0.245258564359423, 0.122242429111897], [
                               0.050671935660746, 0.081648277010661, -0.034403618638332, -0.604379533928053,
                               0.029715665982435, -0.255779368776897, -0.321832198773717, -0.454789288464763,
                               -0.04205042244723, 0.49580649289475], [
                               -0.580165394752893, 0.155095038022222, 0.210065625307939, 0.265731671126386,
                               -0.481942328396859, 0.107406464626288, -0.031135086609527, 0.076014134025855,
                               -0.182793563791557, 0.490558019238156], [
                               0.525119522958187, -0.007317154673771, -0.078860784151735, -0.118095618729855,
                               -0.388828033497333, -0.11024307003898, -0.140281776355321, 0.496093855143328,
                               -0.517431971433034, 0.084650093567346], [
                               -0.221934029584865, 0.08937666134435, -0.161579047653623, -0.202383925865339,
                               -0.358394121525824, 0.305489267359872, -0.319803594563591, -0.329350210528224,
                               -0.279367850055518, -0.604257992994783], [
                               -0.14024729892381, -0.085950562359788, 0.562192927749687, 0.15621897836716,
                               0.259175107289986, -0.401255905586421, -0.564318107548709, 0.125407586464797,
                               -0.135691838706447, -0.227388734136487], [
                               -0.392433919094433, 0.338788001793312, -0.569620515414919, -0.064134166835177,
                               0.436408519589215, -0.115926326668514, -0.12994296127687, 0.36903024504463,
                               -0.213067396847211, 0.016735182121047]])

        if dimensions > len(self.o):
            raise ValueError("Dimensions cannot be higher than o vector")

        if dimensions != 10:
            raise ValueError(f"Dimensions must be 10 for function {self.__class__.__name__}")

        super().__init__(dimensions)

    def evaluate(self, X):
        x = np.array(X)
        z = x + 1 - self.o[:self.D]
        return np.sum([(100 * (z[i] ** 2 - z[i + 1])) ** 2 + (z[i] - 1) ** 2 for i in range(0, len(z) - 1)])

    def constraints(self):
        def h1(X):
            x = np.array(X)
            y = self.M.dot(x - self.o[:self.D])
            return np.sum([_y * sin(sqrt(abs(_y))) for _y in y])

        return {
            "h1":
                {
                    "name": "h1",
                    "func": h1,
                    "op": operator.eq,
                    "target": lambda x: 0
                }
        }

    def get_domain(self):
        return [
            (-500, 500) for _ in range(0, self.D)
        ]


class C11(ConstrainedFunction):

    def __init__(self, dimensions):
        self.o = np.array(
            [0.786412832829728, 0.224970263937584, 0.534200883186777, 0.708371248558908, 0.163080926857473,
             0.768660589584868, 0.1762692231182, 0.310310542254487, 0.279811607250377, 0.825543830090833,
             0.847363744014823, 0.442103825982325, 0.84951329245954, 0.523004716844064, 0.044699072032802,
             0.792400388660219, 0.292824262720788, 0.178722825110973, 0.549380820517875, 0.352736549012222,
             0.080102993555225, 0.853135372349337, 0.790965386853156, 0.951634097517732, 0.809945865440195,
             0.313724260202943, 0.241711589286433, 0.546972335229794, 0.270900015013911, 0.389639306011642])

        self.M = np.array([[0.089633918378866, 0.512130446273224, 0.485514077203757, -0.252958672779915,
                            0.252770541915915, 0.282726797116408, 0.011481584098212, 0.501645726490125,
                            0.182717825231853, 0.031348100000026], [
                               -0.280115239342013, -0.237293103798464, 0.161291392367593, -0.283707496604443,
                               0.364811930990744, -0.062761689119337, -0.739185429285342, -0.191267363255477,
                               0.163852853571301, -0.108948351728692], [
                               -0.054128359479101, 0.280409298113112, -0.705443683949621, -0.251735861726835,
                               0.296849031180373, -0.090813013702513, -0.065957070182011, 0.30050375022829,
                               -0.272322162400478, -0.303711147333872], [
                               -0.452847886193739, 0.236523261801994, -0.24521824465, -0.081379588794718,
                               -0.24525780464972, 0.37821495392415, -0.18193070994583, -0.056246704353941,
                               -0.093664221220625, 0.651150911995366], [
                               0.361083640107602, 0.399352960578869, -0.140221518169126, 0.501290666120365,
                               0.227775075396437, -0.344871729183228, -0.325346508438507, -0.093040278786845,
                               0.207431987018326, 0.332909212543853], [
                               -0.327366108426422, -0.034166615485878, 0.168579539272942, -0.231702366911964,
                               0.292800433946541, -0.648132837341469, 0.361448041200678, 0.046154155969474,
                               -0.131239528768862, 0.392112292683837], [
                               -0.416908196358713, -0.161816318805297, -0.179541440127106, 0.415157611173291,
                               0.440167850594149, 0.25787201771071, 0.30374321406454, 0.077672586210717,
                               0.481631833482542, -0.070029679148627], [
                               -0.082769326821527, -0.296458567384547, -0.095392668680313, 0.079070267285698,
                               -0.410370494920092, -0.277529903950391, -0.232372087468556, 0.707837046116306,
                               0.291065711969018, 0.068801000678567], [
                               -0.314851017910477, 0.037408462116577, 0.292343317100224, 0.548829235267724,
                               0.065696886904918, 0.012681873453724, -0.181476896332993, 0.21693059635943,
                               -0.634666974725221, -0.159748150960876], [
                               0.433769285221923, -0.520307620610873, -0.07481810354657, -0.026992353432197,
                               0.388158769389856, 0.286598385013371, -0.018393693541829, 0.231063340808058,
                               -0.277653756652504, 0.413729117675976]])

        if dimensions > len(self.o):
            raise ValueError("Dimensions cannot be higher than o vector")

        if dimensions != 10:
            raise ValueError(f"Dimensions must be 10 for function {self.__class__.__name__}")

        super().__init__(dimensions)

    def evaluate(self, X):
        x = np.array(X)
        z = self.M.dot(x - self.o[:self.D])
        return (1 / self.D) * np.sum([-1.0 * _z * cos(2 * sqrt(abs(_z))) for _z in z])

    def constraints(self):
        def h1(X):
            x = np.array(X)
            y = x + 1 - self.o[:self.D]
            return np.sum([(100 * (y[i] ** 2 - y[i + 1])) ** 2 + (y[i] - 1) ** 2 for i in range(0, len(y) - 1)])

        return {
            "h1":
                {
                    "name": "h1",
                    "func": h1,
                    "op": operator.eq,
                    "target": lambda x: 0
                }
        }

    def get_domain(self):
        return [
            (-100, 100) for _ in range(0, self.D)
        ]


class C12(ConstrainedFunction):
    def __init__(self, dimensions):
        self.o = np.array(
            [18.889635068428205, -59.265426383246485, 33.25998466165768, 20.152694275194037, -10.734106238462502,
             -90.85053128520764, -12.073899411249897, 59.72307696259165, -37.44193247323578, 25.963111555782035,
             6.251460324561279, 41.478172862575434, 86.54258849813075, 34.94822787072172, 26.864471649916382,
             79.55580868986908, -44.66218241775459, -7.305741544994362, 87.75843366209835, 33.836473236958284,
             84.53385936725138, 80.89850629751817, 48.46967726645195, -82.0758049330533, -98.54273249151939,
             19.55069746505636, 8.33657824668768, 88.54888769408086, -79.08282398956031, 63.254014133387614])

        if dimensions > len(self.o):
            raise ValueError("Dimensions cannot be higher than o vector")

        super().__init__(dimensions)

    def evaluate(self, X):
        x = np.array(X)
        z = x - self.o[:self.D]
        return np.sum([_z * sin(sqrt(abs(_z))) for _z in z])

    def constraints(self):
        def h1(X):
            x = np.array(X)
            z = x - self.o[:self.D]
            return np.sum([(z[i] ** 2 - z[i + 1]) ** 2 for i in range(0, len(z) - 1)])

        def g1(X):
            x = np.array(X)
            z = x - self.o[:self.D]
            return np.sum([_z - 100 * cos(0.1 * _z) for _z in z])

        return {
            "h1":
                {
                    "name": "h1",
                    "func": h1,
                    "op": operator.eq,
                    "target": lambda x: 0
                },
            "g1":
                {
                    "name": "g1",
                    "func": g1,
                    "op": operator.le,
                    "target": lambda x: 0
                }
        }

    def get_domain(self):
        return [
            (-1000, 1000) for _ in range(0, self.D)
        ]


class C13(ConstrainedFunction):
    def __init__(self, dimensions):
        self.o = np.array([69.69311714880897, 1.509803311435702, 67.6746198312362, 80.43173609273597, 80.47622449424348,
                           51.21092936019716, 52.7723719926014, 17.248465789326257, 52.40150903116374,
                           39.64846247456716, 89.86375903333635, 32.079301315169474, 43.192499277837946,
                           70.79294586561508, 1.48440984483988, 19.8566700417119, 29.502667246412756,
                           34.256788127976684, 12.643016541338264, 78.57234385195876, 26.51647349482587,
                           97.06430708087798, 10.180504722002471, 82.90799886855778, 63.540231382573154,
                           74.78243308676124, 87.20817289266436, 50.779655804893764, 43.05412185616204,
                           33.862234518700916])

        if dimensions > len(self.o):
            raise ValueError("Dimensions cannot be higher than o vector")

        super().__init__(dimensions)

    def evaluate(self, X):
        x = np.array(X)
        z = x - self.o[:self.D]
        return (1 / self.D) * np.sum([-_z * sin(sqrt(abs(_z))) for _z in z])

    def constraints(self):
        def g1(X):
            x = np.array(X)
            z = x - self.o[:self.D]
            return -50 + (1 / (100 * self.D)) * np.sum([_z * _z for _z in z])

        def g2(X):
            x = np.array(X)
            z = x - self.o[:self.D]
            return (50 / self.D) * np.sum([sin((1 / 50) * pi * _z) for _z in z])

        def g3(X):
            x = np.array(X)
            z = x - self.o[:self.D]
            return 75 - 50 * (np.sum([_z ** 2 / 4000 for _z in z]) - np.prod(
                [cos(_z / sqrt(i + 1)) for i, _z in enumerate(z)]) + 1)

        return {
            "g1":
                {
                    "name": "g1",
                    "func": g1,
                    "op": operator.le,
                    "target": lambda x: 0
                },
            "g2":
                {
                    "name": "g2",
                    "func": g2,
                    "op": operator.le,
                    "target": lambda x: 0
                },
            "g3":
                {
                    "name": "g3",
                    "func": g3,
                    "op": operator.le,
                    "target": lambda x: 0
                }
        }

    def get_domain(self):
        return [
            (-500, 500) for _ in range(0, self.D)
        ]


class C14(ConstrainedFunction):

    def __init__(self, dimensions):
        self.o = np.array(
            [-31.718907007204272, -39.536680684207184, -46.033718058035944, -42.2004014684422, -28.331307546159135,
             -38.64403177375364, -11.313371899853626, -11.717383190039943, -43.345049558717875, -31.46016185891229,
             -35.57742732758397, -45.49638850141341, -4.177473725277878, -26.974808661067083, -46.30991533784743,
             -45.997883193212814, -29.479673271045964, -4.336542960830036, -43.66244285780764, -22.43896852522004,
             -25.89273808052249, -24.221450510218993, -30.3952886350567, -31.170730638052895, -9.859463575974534,
             -16.727846507426452, -44.35226340706524, -33.10843069426064, -7.175153678947718, -4.601421202670486])

        if dimensions > len(self.o):
            raise ValueError("Dimensions cannot be higher than o vector")

        super().__init__(dimensions)

    def evaluate(self, X):
        x = np.array(X)
        z = x + 1 - self.o[:self.D]
        return np.sum([(100 * (z[i] ** 2 - z[i + 1])) ** 2 + (z[i] - 1) ** 2 for i in range(0, len(z) - 1)])

    def constraints(self):
        def g1(X):
            x = np.array(X)
            z = x + 1 - self.o[:self.D]
            y = x - self.o[:self.D]
            return np.sum([-_y * cos(sqrt(abs(_y))) for _y in y]) - self.D

        def g2(X):
            x = np.array(X)
            z = x + 1 - self.o[:self.D]
            y = x - self.o[:self.D]
            return np.sum([_y * cos(sqrt(abs(_y))) for _y in y]) - self.D

        def g3(X):
            x = np.array(X)
            z = x + 1 - self.o[:self.D]
            y = x - self.o[:self.D]
            return np.sum([_y * cos(sqrt(abs(_y))) for _y in y]) - 10 * self.D

        return {
            "g1":
                {
                    "name": "g1",
                    "func": g1,
                    "op": operator.le,
                    "target": lambda x: 0
                },
            "g2":
                {
                    "name": "g2",
                    "func": g2,
                    "op": operator.le,
                    "target": lambda x: 0
                },
            "g3":
                {
                    "name": "g3",
                    "func": g3,
                    "op": operator.le,
                    "target": lambda x: 0
                }
        }

    def get_domain(self):
        return [
            (-1000, 1000) for _ in range(0, self.D)
        ]


class C15(ConstrainedFunction):

    def __init__(self, dimensions):
        self.o = np.array(
            [-31.718907007204272, -39.536680684207184, -46.033718058035944, -42.2004014684422, -28.331307546159135,
             -38.64403177375364, -11.313371899853626, -11.717383190039943, -43.345049558717875, -31.46016185891229,
             -35.57742732758397, -45.49638850141341, -4.177473725277878, -26.974808661067083, -46.30991533784743,
             -45.997883193212814, -29.479673271045964, -4.336542960830036, -43.66244285780764, -22.43896852522004,
             -25.89273808052249, -24.221450510218993, -30.3952886350567, -31.170730638052895, -9.859463575974534,
             -16.727846507426452, -44.35226340706524, -33.10843069426064, -7.175153678947718, -4.601421202670486])

        self.M = np.array([[-18.785768809450733, 33.616954860437176, 26.882113915382682, -10.43306419742936,
                            0.944892894082476, -3.353896433259691, 3.535212733907637, 7.394276941396782,
                            7.790908752641235, 2.091292109983567], [
                               -0.38080580880289, 10.420967284673154, 9.347291913115678, -20.926490513724943,
                               11.4259031588907, 1.10563725749954, 36.87928250597037, -1.910339780463472,
                               7.56116849320932, -9.743066435789972], [
                               -12.341688082549489, 6.362199355273804, 8.248429939792464, 8.089256366417835,
                               0.069234506619011, 2.578624135957486, -0.497340218618186, -2.062722095484327,
                               1.430205147745766, 15.52200376094467], [
                               -17.00654251044467, -12.679306064055677, 51.65812051951116, -3.97661207806369,
                               3.934938475013658, -30.777202564613845, 6.146597147627116, -11.404959107806402,
                               12.694206030880832, -9.395143228117439], [
                               -5.484749154282662, -13.643476981518553, -20.8125786035429, 12.48063177681885,
                               0.844978205995699, 24.830393330514045, 33.83850518570256, -17.003569707093064,
                               -5.293964367404844, 26.065703095424336], [
                               11.422878520470586, 10.221461943150496, -5.999478987400263, -8.935891602574142,
                               3.340791625151446, 3.924548854255449, -6.760571785727851, 14.016300477765046,
                               2.353396935795215, -15.957358828479556], [
                               14.1069797350053, -0.689797572922294, 25.92835826668488, -30.138271725378775,
                               12.953067028884863, -17.125782201118525, 19.122903237509483, 3.85021017121606,
                               14.44987126033593, -37.768641488073015], [
                               1.817162027385162, -4.52289774299815, 2.596064824368431, -3.077970366333548,
                               3.666238380627702, -3.142271967105208, -1.93910379576585, -1.132846020949443,
                               -1.459397119228072, -4.385065305078107], [
                               17.05963501513677, -40.88734304067851, -9.04136854737176, 9.207816613351653,
                               2.483559081696921, -3.135238286666343, -0.515970843448524, -10.448164970351954,
                               -3.97908386413912, -5.010151763870892], [
                               -2.100410473384162, 4.285743492212902, 18.13880373052391, -5.569156622351854,
                               0.020414928764168, -5.531568307180828, 1.750746232557792, 2.018382353850689,
                               8.96737078655512, -3.593654241962948]])

        if dimensions > len(self.o):
            raise ValueError("Dimensions cannot be higher than o vector")

        if dimensions != 10:
            raise ValueError(f"Dimensions must be 10 for function {self.__class__.__name__}")

        super().__init__(dimensions)

    def evaluate(self, X):
        x = np.array(X)
        z = x + 1 - self.o[:self.D]
        return np.sum([(100 * (z[i] ** 2 - z[i + 1])) ** 2 + (z[i] - 1) ** 2 for i in range(0, len(z) - 1)])

    def constraints(self):
        def g1(X):
            x = np.array(X)
            z = x + 1 - self.o[:self.D]
            y = self.M.dot(x - self.o[:self.D])
            return np.sum([-_y * cos(sqrt(abs(_y))) for _y in y]) - self.D

        def g2(X):
            x = np.array(X)
            z = x + 1 - self.o[:self.D]
            y = self.M.dot(x - self.o[:self.D])
            return np.sum([_y * cos(sqrt(abs(_y))) for _y in y]) - self.D

        def g3(X):
            x = np.array(X)
            z = x + 1 - self.o[:self.D]
            y = self.M.dot(x - self.o[:self.D])
            return np.sum([_y * cos(sqrt(abs(_y))) for _y in y]) - 10 * self.D

        return {
            "g1":
                {
                    "name": "g1",
                    "func": g1,
                    "op": operator.le,
                    "target": lambda x: 0
                },
            "g2":
                {
                    "name": "g2",
                    "func": g2,
                    "op": operator.le,
                    "target": lambda x: 0
                },
            "g3":
                {
                    "name": "g3",
                    "func": g3,
                    "op": operator.le,
                    "target": lambda x: 0
                }
        }

    def get_domain(self):
        return [
            (-1000, 1000) for _ in range(0, self.D)
        ]


class C16(ConstrainedFunction):

    def __init__(self, dimensions):
        self.o = np.array(
            [0.365972807627352, 0.429881383400138, -0.420917679577772, 0.984265986788929, 0.324792771198785,
             0.463737106835568, 0.989554882052943, 0.307453878359996, 0.625094764380575, -0.358589007202526,
             0.24624504504104, -0.96149609569083, -0.184146201911073, -0.030609388103067, 0.13366054512765,
             0.450280168292005, -0.662063233352676, 0.720384516339946, 0.518473305175091, -0.969074121149791,
             -0.221655317677079, 0.327361832246864, -0.695097713581401, -0.671724285177815, -0.534907819936839,
             -0.003991036739113, 0.486452090756303, -0.689962754053575, -0.138437260109118, -0.626943354458217])

        if dimensions > len(self.o):
            raise ValueError("Dimensions cannot be higher than o vector")

        super().__init__(dimensions)

    def evaluate(self, X):
        x = np.array(X)
        z = x - self.o[:self.D]
        a = np.sum([(_z ** 2) / 4000 for _z in z])
        # i+1 because we start from 1
        b = np.prod([cos(_z / sqrt(i + 1)) for i, _z in enumerate(z)])
        return a - b + 1

    def constraints(self):
        def g1(X):
            x = np.array(X)
            z = x - self.o[:self.D]
            return np.sum([_z * _z - 100 * cos(pi * _z) + 10 for _z in z])

        def g2(X):
            x = np.array(X)
            z = x - self.o[:self.D]
            return np.prod(z[:self.D])

        def h1(X):
            x = np.array(X)
            z = x - self.o[:self.D]
            return np.sum([_z * sin(sqrt(abs(_z))) for _z in z])

        def h2(X):
            x = np.array(X)
            z = x - self.o[:self.D]
            return np.sum([_z * -1. * sin(sqrt(abs(_z))) for _z in z])

        return {
            "g1":
                {
                    "name": "g1",
                    "func": g1,
                    "op": operator.le,
                    "target": lambda x: 0
                },
            "g2":
                {
                    "name": "g2",
                    "func": g2,
                    "op": operator.le,
                    "target": lambda x: 0
                },
            "h1":
                {
                    "name": "h1",
                    "func": h1,
                    "op": operator.eq,
                    "target": lambda x: 0
                },
            "h2":
                {
                    "name": "h2",
                    "func": h2,
                    "op": operator.eq,
                    "target": lambda x: 0
                }
        }

    def get_domain(self):
        return [
            (-10, 10) for _ in range(0, self.D)
        ]


class C17(ConstrainedFunction):

    def __init__(self, dimensions):
        self.o = np.array(
            [-0.628245703945122, 0.331024455127249, 0.402617203423807, 0.462742527496583, -0.513329779137884,
             0.288191632492259, 0.41479349370103, 0.916196063289011, -0.427742767473712, 0.811971694633694,
             -0.202953396286476, 0.786617208861492, -0.583805982901842, 0.91666360939369, -0.602135912772221,
             0.503807046950863, -0.196264987447976, -0.565579687152807, 0.540878947793462, 0.183666358669345,
             -0.303576255198908, -0.896405440407756, -0.101939801890135, -0.049819872322279, 0.434240825173134,
             0.946552963504364, -0.32578927683003, -0.154255792477949, 0.577967633549953, -0.573697797217518])

        if dimensions > len(self.o):
            raise ValueError("Dimensions cannot be higher than o vector")

        super().__init__(dimensions)

    def evaluate(self, X):
        x = np.array(X)
        z = x - self.o[:self.D]
        a = [z[i] - z[i + 1] for i in range(0, self.D - 1)]
        return np.sum([_z * _z for _z in a])

    def constraints(self):
        def g1(X):
            x = np.array(X)
            z = x - self.o[:self.D]
            return np.prod([_z for _z in z])

        def g2(X):
            x = np.array(X)
            z = x - self.o[:self.D]
            return np.sum([_z for _z in z])

        def h1(X):
            x = np.array(X)
            z = x - self.o[:self.D]
            return np.sum([_z * sin(4 * sqrt(abs(_z))) for _z in z])

        return {
            "g1":
                {
                    "name": "g1",
                    "func": g1,
                    "op": operator.le,
                    "target": lambda x: 0
                },
            "g2":
                {
                    "name": "g2",
                    "func": g2,
                    "op": operator.le,
                    "target": lambda x: 0
                },
            "h1":
                {
                    "name": "h1",
                    "func": h1,
                    "op": operator.eq,
                    "target": lambda x: 0
                }
        }

    def get_domain(self):
        return [
            (-10, 10) for _ in range(0, self.D)
        ]


class C18(ConstrainedFunction):

    def __init__(self, dimensions):
        self.o = np.array(
            [-2.494401436611803, -0.306408781638572, -2.271946840536718, 0.381278325914122, 2.394875929583502,
             0.418708663782934, -2.082663588220074, 0.776060342716238, -0.374312845903175, 0.352372662321828,
             1.172942728375508, -0.24450210952894, 1.049793874089803, -1.716285448140795, -1.026167671845868,
             -1.223031642604231, 0.924946651665792, 0.93270056541258, -2.312880521655027, -0.671857644927313,
             -0.312276658254605, -0.973986111708943, -0.454151248193331, 2.420597958989111, 0.050346805172393,
             1.050203106200361, -0.05420584346617, -0.081533357726523, -0.968176219532845, 1.682281307624435])

        if dimensions > len(self.o):
            raise ValueError("Dimensions cannot be higher than o vector")

        super().__init__(dimensions)

    def evaluate(self, X):
        x = np.array(X)
        z = x - self.o[:self.D]
        a = [z[i] - z[i + 1] for i in range(0, self.D - 1)]
        return np.sum([_z * _z for _z in a])

    def constraints(self):
        def g1(X):
            x = np.array(X)
            z = x - self.o[:self.D]
            return (1 / self.D) * np.sum([-_z * sin(sqrt(abs(_z))) for _z in z])

        def h1(X):
            x = np.array(X)
            z = x - self.o[:self.D]
            return (1 / self.D) * np.sum([_z * sin(sqrt(abs(_z))) for _z in z])

        return {
            "g1":
                {
                    "name": "g1",
                    "func": g1,
                    "op": operator.le,
                    "target": lambda x: 0
                },
            "h1":
                {
                    "name": "h1",
                    "func": h1,
                    "op": operator.eq,
                    "target": lambda x: 0
                }
        }

    def get_domain(self):
        return [
            (-50, 50) for _ in range(0, self.D)
        ]
